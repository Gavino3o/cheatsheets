\documentclass[10pt, landscape]{article}
\usepackage[scaled=0.92]{helvet}
\usepackage{calc}
\usepackage{multicol}
\usepackage[a4paper,margin=3mm,landscape]{geometry}
\usepackage{amsmath,amsthm,amsfonts,amssymb}
\usepackage{color,graphicx,overpic}
\usepackage{hyperref}
\usepackage{newtxtext} 
\usepackage{enumitem}
\usepackage[table]{xcolor}
\usepackage{mathtools}
\setlist{nosep}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric}

% for including images
\graphicspath{ {./images/} }


\pdfinfo{
  /Title (CS2102.pdf)
  /Creator (TeX)
  /Producer (pdfTeX 1.40.0)
  /Author (Jovyn Tan)
  /Subject (CS2102)
/Keywords (CS2102, nus,cheatsheet,pdf)}

% Turn off header and footer
\pagestyle{empty}

% redefine section commands to use less space
\makeatletter
\renewcommand{\section}{\@startsection{section}{1}{0mm}%
  {-1ex plus -.5ex minus -.2ex}%
  {0.5ex plus .2ex}%x
{\normalfont\large\bfseries}}
\renewcommand{\subsection}{\@startsection{subsection}{2}{0mm}%
  {-1explus -.5ex minus -.2ex}%
  {0.5ex plus .2ex}%
{\normalfont\normalsize\bfseries}}
\renewcommand{\subsubsection}{\@startsection{subsubsection}{3}{0mm}%
  {-1ex plus -.5ex minus -.2ex}%
  {1ex plus .2ex}%
{\normalfont\small\bfseries}}%
\makeatother

\renewcommand{\familydefault}{\sfdefault}
\renewcommand\rmdefault{\sfdefault}
%  makes nested numbering (e.g. 1.1.1, 1.1.2, etc)
\renewcommand{\labelenumii}{\theenumii}
\renewcommand{\theenumii}{\theenumi.\arabic{enumii}.}
\renewcommand\labelitemii{•}
\renewcommand\labelitemiii{•}

\definecolor{mathblue}{cmyk}{1,.72,0,.38}
\everymath\expandafter{\the\everymath \color{mathblue}}

% Don't print section numbers
\setcounter{secnumdepth}{0}

\setlength{\parindent}{0pt}
\setlength{\parskip}{0pt plus 0.5ex}
%% this changes all items (enumerate and itemize)
\setlength{\leftmargini}{0.5cm}
\setlength{\leftmarginii}{0.5cm}
\setlist[itemize,1]{leftmargin=2mm,labelindent=1mm,labelsep=1mm}
\setlist[itemize,2]{leftmargin=4mm,labelindent=1mm,labelsep=1mm}

% adding my commands
\input{../commands/style-helpers.tex}
\input{../commands/code.tex}
\input{../commands/math.tex}
\input{../commands/joins.tex}
% -----------------------------------------------------------------------

\begin{document}
\raggedright
\footnotesize
\begin{multicols}{3}

  % multicol parameters
  % These lengths are set only within the two main columns
  \setlength{\columnseprule}{0.25pt}
  \setlength{\premulticols}{1pt}
  \setlength{\postmulticols}{1pt}
  \setlength{\multicolsep}{1pt}
  \setlength{\columnsep}{2pt}

  \begin{center}
    \fbox{%
      \parbox{0.8\linewidth}{\centering \textcolor{black}{
          {\Large\textbf{CS2102}}
        \\ \normalsize{AY21/22 SEM 1}}
        \\ {\footnotesize \textcolor{gray}{github/jovyntls}}
      }%
    }
  \end{center}

  \section{01. DBMS: DATABASE MANAGEMENT SYSTEMS}
  \begin{itemize}
    \item set of universal and powerful \textbf{functionalities}  for data management
    \item \textbf{database system}: DBMS (functionality) supporting several databases
      \begin{itemize}
        \item DBS = DMBS + n*DB
      \end{itemize}
    \item \textbf{data model}: framework to specify the structure of a DB
    \item \textbf{schema}: describes the DB structure using concepts provided by the data model
    \item \textbf{schema instance}: content of a DB at a particular time
  \end{itemize}

  \subsection{Transactions}
  \begin{itemize}
    \item \textbf{transaction}, \(T\): a finite sequence of database operations
      \begin{itemize}
        \item smallest logical unit of work from an application perspective
      \end{itemize}
    \item guarantees the \textbf{ACID} properties
  \end{itemize}
  \begin{tightcenter}
    \includegraphics[width=0.9\linewidth]{cs2102-transition-graph.png}
  \end{tightcenter}

  \subsubsection{ACID properties}
  \begin{enumerate}
    \item \textbf{Atomicity} \(\rightarrow\) either all effects of $ T $ are reflected in the database, or none
    \item \textbf{Consistency}  \(\rightarrow\) the execution of $ T $ guarantees to yield a \textit{correct state} of the DB
    \item \textbf{Isolation} \(\rightarrow\)  execution of T is \textit{isolated} from the effects of concurrent transactions
    \item \textbf{Durability} \(\rightarrow\) after the commit of $ T $, its effects are \textit{permanent}  in case of failures
  \end{enumerate}

  \subsection{Serial vs Concurrent Execution}
  \subsubsection{Serial Execution}
  \begin{itemize}
    \item $ \checkmark $ \textit{correct} final result
    \item $ \times $ less (unoptimised) resource utilisation; low throughput
  \end{itemize}

  \subsubsection{Serializability}
  \begin{itemize}
    \item Requirement for Concurrent Execution: \textbf{serializable transaction execution} 
      \begin{itemize}
        \item (concurrent execution of a set of transactions is) \textbf{serializable} \(\rightarrow\) execution is equivalent to some serial execution of the same set of transactions
        \item \textbf{equivalent} \(\rightarrow\) they have the same \textit{effect}  on the data
      \end{itemize}
  \end{itemize}

  \subsubsection{Core tasks of DBMS}
  \begin{itemize}
    \item Support \textit{concurrent executions} of transactions - to optimise performance
    \item enforce \textit{serializability} of concurrent executions - to ensure integrity of data
  \end{itemize}

  \section{01-1. RELATIONAL MODEL}
  \begin{itemize}
    \item \definition{relation schema} defines a relation
      \begin{itemize}
        \item specifies the \textbf{attributes} (columns) and data constraints
        \item \definition{data constraints} limits the kind of data you can put into the database
      \end{itemize}
    \item \definition{relational database schema} set of relation schemas + data constraints
      \begin{itemize}
        \item TableName(col\_1, col\_2, col\_3) with dom(col\_1) = \{x, y, z\}, ...
      \end{itemize}
    \item \definition{relational database} collection of tables
  \end{itemize}

  \begin{itemize}
    \item \definition{domain} a set of \textit{atomic} values
      \begin{itemize}
        \item domain of attribute $ A_i $, $ dom(A_i) =$ set of possible values for $ A_i $
        \item for each value $ v $ of attribute $ A_i $, $ v \in dom(A_i) $ or $ v = $ \code{null}
          \begin{itemize}
            \item \code{null}: special value indicating that $ v $ is not known or specified
          \end{itemize}
        \item e.g. dom(course) = \{cs2102, cs2030, cs2040\}
      \end{itemize}
    \item \definition{relation} a set of \textit{tuples} 
      \begin{itemize}
        \item $ R(A_1, A_2, \dots, A_n) $ : relation schema with name $ R $ and $ n $ attributes $ A_1, A_2, \dots, A_n $
        \item each instance of schema $ R $ is a relation which is a subset of $ \{(a_1, a_2, \dots, a_n) \mid a_i \in dom(A_i) \cup \{null\}\} $
      \end{itemize}
  \end{itemize}


  \section{01-2. ENSURING DATA INTEGRITY}
  \begin{itemize}
    \item \definition{integrity constraint} condition that restricts what constitutes valid data
      \begin{itemize}
        \item DBMS will check that tables only ever contain valid data
      \end{itemize}
    \item \definition{structural} (integrity) inherent to the data model 
    \item 3 main strucutral integrity constraints of the Relation Model
      \begin{enumerate}
        \item Domain constraints
        \item Key constraints
        \item Foreign key constraints
      \end{enumerate}
  \end{itemize}

  \subsection{Key Constraints}
  \begin{itemize}
    \item \definition{superkey} subset of attributes that \textit{uniquely} identifies a tuple in a relation
      \begin{itemize}
        \item e.g. \{id, title\}
      \end{itemize}
    \item \definition{key} superkey that is also \textbf{minimal} 
      \begin{itemize}
        \item no proper subset of the key is a superkey
        \item e.g. \{id\}
      \end{itemize}
    \item \definition{candidate keys} set of all keys for a relation
    \item \definition{primary key} selected candidate key for a relation
      \begin{itemize}
        \item \textit{cannot} be \code{null} $ \Rightarrow $  \textbf{entity integrity constraint} 
      \end{itemize}
  \end{itemize}

  \subsection{Foreign Key Constraints}
  \begin{itemize}
    \item \definition{foreign key} subset of attributes of relation $ A $ if it refers to the \textit{primary key}  in a relation $ B $.
    \item each foreign key in a relation must:
      \begin{enumerate}
        \item appear as a \textbf{primary key} in the referenced relation, OR:
        \item be a \code{null} value
      \end{enumerate}
  \end{itemize}

  \section{01-3. SUMMARY}
  \begin{tightcenter}
    \includegraphics[width=0.9\linewidth]{cs2102-relational-model-example.png}
  \end{tightcenter}

  \section{02. RELATIONAL ALGEBRA}
  \begin{itemize}
    \item \definition{algebra} mathematical system of operands and operators
      \begin{itemize}
        \item \textbf{operands}: variables or values from which new values can be constructed
        \item \textbf{operators}: symbols denoting procedures that construct new values from given values
      \end{itemize}
    \item \definition{relation algebra} procedural query language
      \begin{itemize}
        \item \textbf{operands}: relations or variables representing relations
        \item \textbf{operators}: transform one or more input relations into one output relation
      \end{itemize}
  \end{itemize}

  \subsection{Closure Property}
  \begin{itemize}
    \item \definition{closure} relations are \textit{closed}  under relational algebra
      \begin{itemize}
        \item all input operands and outputs of all operators are \textit{relations} 
        \item the output of one operator can serve as input for subsequent operators
      \end{itemize}
    \item allows for nesting of relational operators $\Rightarrow$ \textbf{relational algebra expressions} 
  \end{itemize}

  \section{02-1. BASIC OPERATORS}
  \subsection{UNARY OPERATORS}

  \subsubsection{Selection, $ \sigma_c $}
  \begin{itemize}
    \item \definition{$\sigma_c(R)$} selects all tuples from a relation  $ R $ (i.e. rows from a table) that satisfy condition $ c $.
      \begin{itemize}
        \item for each tuple $ t \in R, t \in \sigma_c(R) \iff c $ evaluates to true on $ t $ 
        \item input and output relation have the same schema
      \end{itemize}
    \item \definition{selection condition} 
      \begin{itemize}
        \item a \textit{boolean expression} of one of the following forms:
          \begin{itemize}
            \item constant selection - attribute \textbf{op} constant
            \item attribute selection - attribute$_1$ \textbf{op} attribute$_2$
            \item expr$_1 \land $ expr$ _2 ; \quad$ expr$_1 \lor $ expr$ _2 ; \quad$ item $ \lnot $ expr $ ; \quad $(expr)
          \end{itemize}
        \item with \textbf{op} $\in \{=, <>, <, \leq, \geq, >\}$
          \begin{itemize}
            \item \textbf{operator precedence}: (), \textbf{op}, $\lnot$, $\land$, $\lor$
          \end{itemize}
        \item handling \code{null} values
          \begin{itemize}
            \item comparison operation with \code{null} $\Rightarrow$ \textbf{unknown} 
            \item arithmetic operation with \code{null} $\Rightarrow$ \code{null} 
          \end{itemize}
      \end{itemize}
  \end{itemize}

  \subsubsection{Projection, $\pi_\ell$}
  \begin{itemize}
    \item \definition{$\pi_\ell(R)$} projects all attributes of a given \textbf{relation}  specified in list $\ell$
      \begin{itemize}
        \item \textit{relation} = set of tuples $\Rightarrow$ duplicates removed from output relation!
        \item \textbf{order} of attributes matters!
        \item i.e. projects all columns of a table specified in list $\ell$
      \end{itemize}
  \end{itemize}

  \subsubsection{Renaming, $\rho_\ell$}
  \begin{itemize}
    \item \definition{$\rho_\ell(R)$} renames the attributes of a relation  $R$ 
      \\* $R$ is a relation with schema $R(A_1, A_2, \dots, A_n)$
    \item 2 possible formats for $\ell$
      \begin{itemize}
        \item $\ell$ is the new \textit{schema} in terms of the new attribute names
          \begin{itemize}
            \item $\ell = (B_1, B_2, \dots, B_n)$; $B_i = A_i$ if attribute $A_i$ does not get renamed
          \end{itemize}
        \item $\ell$ is a list of attribute renamings of the form: $B_i \leftarrow A_i, \dots, B_k \leftarrow A_k$
          \begin{itemize}
            \item each renaming $B_j \leftarrow A_j$ renames attribute $A_j$ to attribute $B_j$
            \item order of renaming doesn't matter
          \end{itemize}
      \end{itemize}
  \end{itemize}

  \subsection{SET OPERATORS}
  \begin{itemize}
    \item \definition{union} $R \cup S$ returns a relation with all tuples that are in both $R$ \textbf{or}  $S$
    \item \definition{intersection} $R \cap S$ ... all tuples that are in both $R$ \textbf{and}  $S$ 
    \item \definition{set difference} $R - S$ ... all the tuples that are in  $R$ \textbf{but not in}  $S$
  \end{itemize}
  ! requirement for all set operators: $R$ and $S$ must be \textbf{union-compatible} 

  \subsubsection{Union Compatibility}
  \begin{itemize}
    \item two relations $R$ and $S$ are \definition{union-compatible} if
      \begin{itemize}
        \item $R$ and $S$ have the same number of attributes and
        \item the corresponding attributes have the \textit{same or compatible domains} 
        \item BUT $R$ and $S$ do not have to use the same attribute names
      \end{itemize}
  \end{itemize}

  \subsection{CROSS PRODUCT}
  \begin{itemize}
    \item \definition{cross product} combines two relations $R$ and $S$ by forming all pairs of tuples from the two relations
      \begin{itemize}
        \item given two relations $R(A, B, C)$ and $S(X, Y)$,  $R \times S$ returns a relation with schema $(A, B, C, X, Y)$ defined as 
          \\* $R \times S = \{(a, b, c, x, y) \mid (a, b, c) \in R, (x, y) \in S\}$
      \end{itemize}
    \item \textbf{size} of cross product $= \abs{R}*\abs{S}$
  \end{itemize}

  \section{02-2. JOIN OPERATORS}

  \subsection{Inner Joins $\theta$-join}
  \begin{itemize}
    \item eliminate all tuples that do not satisfy a matching criteria (i.e. \textbf{attribute selection} )
  \end{itemize}
  $\theta$-join
  \begin{itemize}
    \item the $\theta$-join $R\bowtie_\theta S$ of two relations $R$ and $S$ is defined as
      \begin{tightcenter}
        \( {\displaystyle{R \bowtie_\theta S = \sigma_\theta(R \times S)}} \) 
      \end{tightcenter}
  \end{itemize}

  Equi Join  $\Join$
  \begin{itemize}
    \item special case of $\theta$-join defined over the  \textbf{equality} operator ($=$) only
  \end{itemize}

  Natural Join $\Join$ 
  \begin{itemize}
    \item the \definition{natural join} (of two relations $R$ and $S$) is defined as 
      \\* $R \Join S = \pi_\ell(R\Join_c \rho_{b_i \leftarrow a_i, \dots, b_k \leftarrow a_k}(S))$
      \begin{itemize}
        \item $A=\{a_i, \dots, a_k\}$ is the set of attributes that $R$ and $S$ have in common
        \item $c = ((a_i = b_i) \land \dots \land (a_k = b_k))$
        \item $\ell =$ list of all attributes of $R$ + list of all attributes in $S$ that are \textbf{not in}  $A$
      \end{itemize}
    \item performed over all attributes that $R$ and $S$ have in common
      \begin{itemize}
        \item no explicit matching criteria has to be specified
      \end{itemize}
    \item output relation contains the common attributes of $R$ and $S$ only \textit{once} 
  \end{itemize}

  \subsection{Outer Joins}
  \begin{itemize}
    \item \definition{dangling tuples} tuples in $R$ or $S$ that do not match with tuples in the other relation
      \begin{itemize}
        \item \definition{$\textit{dangle}(R \Join_\theta S)$} set of dangling tuples in  $R$ wrt to $R \Join_\theta S$
          \begin{itemize}
            \item $\textit{dangle}(R \Join_\theta S) \subseteq R$
          \end{itemize}
        \item always removed by inner joins, kept by outer joins
        \item missing attribute values are padded with \code{null} 
      \end{itemize}
    \item \definition{$null(R)$} $n$-component \textbf{tuple}  of \code{null} values where $n$ is the number of attributes of $R$
  \end{itemize}

  \subsubsection{Definitions}
  \begin{itemize}
    \item \definition{left outer join}$R \lojoin_\theta S = R \Join_\theta S \cup (\textit{dangle}(R \Join_\theta S) \times \{\textit{null}(S)\}) $
    \item \definition{right outer join}$R \rojoin_\theta S = R \Join_\theta S \cup (\{\textit{null}(R)\} \times \textit{dangle}(S \Join_\theta R))$
    \item \definition{full outer join}$R \lojoin_\theta S$
      \\* $= R \Join_\theta S \cup (\textit{dangle}(R \Join_\theta S) \times \{\textit{null}(S)\}) \cup (\{\textit{null}(R)\} \times \textit{dangle}(S \Join_\theta R))$
  \end{itemize}

  \subsubsection{Natural Outer Joins}
  \begin{itemize}
    \item only equality operator is used for the join condition
    \item join is performed over all attributes that R and S have in common
    \item  output relation contains the common attributes of R and S only once
  \end{itemize}

  \section{03. SQL}
  \subsection{Overview}
  \begin{itemize}
    \item \textbf{domain-specific language} - used for relational databases
    \item \textbf{declarative language} - focuses on \textit{what} to compute, not \textit{how} to compute
    \item built on top of RA
    \item query = \code{SELECT} statement
  \end{itemize}

  \subsection{Data Types (psql)}
  \begin{itemize}
    \item user-defined types
    \item basic data types
      \begin{tightcenter}
        {\rowcolors{2}{gray!15}{gray!5}\begin{tabular}
            {ccc}
            \rowcolor{cyan!10} 
            \textbf{type} & \textbf{description} \\ \hline 
            boolean & logical Boolean \\ 
            integer & signed 4-byte integer \\
            float8 & double precision floating point number (8 bytes) \\
            numeric[(p, s)] & exact numeric of selectable preciison \\
            char(n) & fixed-length character string \\
            varchar(n) & variable-length character string \\
            text & variable-length character string \\
            date & calendar date (year month day) \\
            timestamp & date and time \\
            \hline
          \end{tabular}
        }
      \end{tightcenter}
    \item char, varchar, text: different sizes to optimise storage
      \begin{itemize}
        \item \code{varchar(n)} - $n$ is the maximum length 
        \item \code{char(n)} - storage size = maximum size = n (will be padded up to $n$ bytes)
        \item \code{text} - usually for very long strings
      \end{itemize}
  \end{itemize}

  \subsection{Types of Commands/Statements}
  \begin{tightcenter}
    \includegraphics[width=0.9\linewidth]{cs2102-sql-query-types.png}
  \end{tightcenter}

  \subsection{DDL (Data Definition)}

  \subsubsection{Create Tables}
  \begin{lstlisting}[style=mySQL]
CREATE TABLE Employees (
id     INTEGER,
name   VARCHAR(50),
age    INTEGER,
role   VARCHAR(50)
);
  \end{lstlisting}

  \subsubsection{Insert Data}
  \begin{lstlisting}[style=mySQL]
-- specifying all attribute values
INSERT INTO Employees VALUES (101, 'John', 25, 'developer');
-- specifying selected attribute values
INSERT INTO Employees (id, name) VALUES (102, 'Smith');
  \end{lstlisting}

  \subsubsection{Modify Schema}
  \begin{lstlisting}[style=mySQL]
-- change data type 
ALTER TABLE Projects ALTER COLUMN name TYPE VARCHAR(200); 
-- set default value 
ALTER TABLE Projects ALTER COLUMN start_year SET DEFAULT 2021; 
-- drop default value
ALTER TABLE Projects ALTER COLUMN start_year DROP DEFAULT; 
-- add new column with a default value
ALTER TABLE Projects ADD COLUMN budget NUMERIC DEFAULT 0.0; 
-- drop column from table
ALTER TABLE Projects DROP COLUMN budget; 
-- add constraint
ALTER TABLE Teams ADD CONSTRAINT eid_fkey FOREIGN KEY (eid) REFERENCES Employees (id);
-- drop constraint
ALTER TABLE Teams DROP CONSTRAINT eid_fkey; /* eid_fkey = name of constraint */
  \end{lstlisting}

  \subsubsection{Drop Tables}
  \begin{lstlisting}[style=mySQL]
DROP TABLE Projects;
-- check first if table exists; avoids throwing an error
DROP TABLE IF EXISTS Projects; 
-- will also delete FK constraint (but not referencing tables)
DROP TABLE Projects CASCADE; 
  \end{lstlisting}

  \subsection{DML (Data Manipulation)}

  \subsubsection{Delete Data}
  \begin{lstlisting}[style=mySQL]
-- deletes all tuples 
DELETE FROM Employees; 
-- deletes selected tuples
DELETE FROM Employees WHERE role='developer';
  \end{lstlisting}

  \subsubsection{Update Data}
  \begin{lstlisting}[style=mySQL]
UPDATE Employees 
SET age = age + 1
WHERE name = 'John';

UPDATE Employees
SET name=UPPER(name), 
    job=UPPER(job);

-- updates all values 
UPDATE Employees 
SET age = 0; 
  \end{lstlisting}

  \subsection{Handling NULLs}
  \begin{itemize}
    \item prerequisite for integrity constraints
    \item \textbf{comparison} operation with \code{null} $\Rightarrow$ \textit{unknown}
    \item \textbf{arithmetic} operation with \code{null} $\Rightarrow$ \code{null}
  \end{itemize}

  \subsubsection{IS (NOT) NULL comparison predicate}
  \begin{itemize}
    \item checks if values are equal to \code{null} 
      \begin{itemize}
        \item evaluates to true \textbf{iff} x is \code{null}
      \end{itemize}
    \item \code{x IS NOT NULL} $\equiv$ \code{NOT (x IS NULL)}
  \end{itemize}

  \subsubsection{IS (NOT) NOT DISTINCT comparison predicate}
  \begin{itemize}
    \item equivalent to $x <> y$ if $x$ and $ y$ are non-\code{null} values
      \begin{itemize}
        \item $x$ and $y$ both \code{null} $\Rightarrow$ \textit{false}
        \item only one value is \code{null} $\Rightarrow$ \textit{true}
      \end{itemize}
    \item \code{x IS NOT DISTINCT FROM y} $\equiv$ \code{NOT (x IS DISTINCT FROM y)}
  \end{itemize}
  \begin{tightcenter}
    {\rowcolors{2}{gray!15}{gray!5}\begin{tabular}
        {cccc}
        \rowcolor{cyan!10} 
        \textbf{x} & \textbf{y} & xy & \texttt{x IS DISTINCT FROM y} \\ \hline 
        1 & 1 & FALSE & FALSE \\ 
        1 & 2 & TRUE & TRUE \\
        \textit{null} & 1 & \textit{null} & TRUE \\
        \textit{null} & \textit{null} & \textit{null} & FALSE \\
        \hline
      \end{tabular}
    }
  \end{tightcenter}

  \section{03-1. CONSTRAINTS}
  \begin{itemize}
    \item \textbf{named}: name assigned by DBMS
    \item \textbf{unnamed}: name is specified - easier bookkeeping
    \item all column constraints can be specified as table constraints, except \code{NOT NULL}
      \begin{itemize}
        \item table constraints referring to a single column can be writen as column constraints
        \item column and table constraints can be combined
          \begin{lstlisting}[style=mySQL]
  ... id INTEGER NOT NULL,
  ...
  UNIQUE(id)
          \end{lstlisting}
      \end{itemize}
  \end{itemize}
  \subsection{Not-Null Constraints}
  \begin{lstlisting}[style=mySQL]
CREATE TABLE Employees (
  id   INTEGER NOT NULL, /* unnamed */
  name VARCHAR(50) CONSTRAINT nn_name NOT NULL, /* named */
  age  INTEGER,
  job  VARCHAR(50),
);
  \end{lstlisting}

  \subsection{Unique Constraints}
  \begin{itemize}
    \item \textbf{violation} (of a unique constraint defined on attributes $A$ and $B$):
      \begin{itemize}
        \item For any two tuples $t_i, t_k \in$ R, \\*
          $(t_i\cdot A <> t_k\cdot A)$ or  $(t_i\cdot B <> t_k \cdot B)$ evaluates to  \textbf{false}
        \item  !!! \code{null} rows will NOT violate unique key constraints
      \end{itemize}
    \item (un)named column constraint \\*
      \begin{lstlisting}[style=mySQL]
CREATE TABLE Employees (
  id   INTEGER UNIQUE, /* unnamed */
  pid  INTEGER CONSTRAINT u_id UNIQUE, /* named */
  name VARCHAR(50), age INTEGER,
  role VARCHAR(50)
);
      \end{lstlisting}
    \item (un)named table constraint
      \begin{lstlisting}[style=mySQL]
CREATE TABLE Employees (
  id   INTEGER,
  name VARCHAR(50), 
  UNIQUE(id),  /* unnamed */,
  CONTRAINT u_name UNIQUE (name) /* named */
);
      \end{lstlisting}
    \item unique constraints for multiple attributes: can only be specified using \textbf{table} constraints
      \begin{lstlisting}[style=mySQL]
CREATE TABLE Employees (
  id     INTEGER,
  name   VARCHAR(50),
  UNIQUE (id, name), /* unnamed */
  CONSTRAINT u_allocation (id, name)  /* named */
)
      \end{lstlisting}
  \end{itemize}

  \subsection{Primary Key Constraints}
  \begin{itemize}
    \item \definition{prime attributes} attributes of the primary key 
      \begin{itemize}
        \item cannot be null
      \end{itemize}
    \item primary key vs \code{UNIQUE NOT NULL}
      \begin{itemize}
        \item \code{UNIQUE NOT NULL} is a candidate key
        \item max 1 primary key, but any number of \code{UNIQUE NOT NULL} constraints
        \item FK constraints are only applicable to PKs in referenced table
      \end{itemize}
    \item PK contraint for one attribute:
      \begin{lstlisting}[style=mySQL]
CREATE TABLE Teams (
  eid INTEGER PRIMARY KEY, 
  ... 
);
      \end{lstlisting}
    \item PK constraint for multiple attributes:
      \begin{lstlisting}[style=mySQL]
CREATE TABLE Teams (
  eid INTEGER,
  pname VARCHAR(100),
  PRIMARY KEY (ename, pname), /* unnamed */
  CONSTRAINT pk_alloc PRIMARY KEY (eid, pname) /* named */
);
      \end{lstlisting}
  \end{itemize}

  \subsection{Foreign Key Constraints}
  \begin{itemize}
    \item each FK in the referencing relation \textbf{must}:
      \begin{itemize}
        \item appear as a PK in the referenced relation, OR
        \item be a \code{null} value
      \end{itemize}
  \end{itemize}
  \begin{lstlisting}[style=mySQL]
CREATE TABLE Teams (
  eid INTEGER,
  pname VARCHAR(100),
  hours INTEGER,
  PRIMARY KEY (ename, pname),
  /* Teams.eid -> Employees.id */
  FOREIGN KEY (eid) REFERENCES Employees (id), 
  /* Teams.pname -> Projects.name */
  FOREIGN KEY (pname) REFERENCES Projects (name)
);
  \end{lstlisting}

  \subsubsection{specifications for table changes}
  \begin{itemize}
    \item \code{ON DELETE/UPDATE}: Specify action in case of the violation of a foreign key constraint
      \begin{itemize}
        \item attempting to delete primary key will throw error if ON DELETE not specified
        \item specify behavior when data in referenced table changes
      \end{itemize}
    \item possible actions:
      \begin{itemize}
        \item \code{NO ACTION}: (\textbf{default value}) - rejects the delete/update if it violates constraint
        \item \code{RESTRICT}: similar to \code{NO ACTION}; checks that constraint cannot be deferred
        \item \code{CASCADE}: propagates delete/update to referencing tuples
        \item \code{SET DEFAULT}: updates FKs of referencing tuples to a specified default value
          \begin{itemize}
            \item !! default value must be a PK in the referenced table !!
          \end{itemize}
        \item \code{SET NULL}: update FKs of referencing tuples to \code{null}
          \begin{itemize}
            \item be careful for primary attributes
            \item corresponding column must be allowed to contain \code{null} values!
          \end{itemize}
      \end{itemize}
  \end{itemize}
  \begin{lstlisting}[style=mySQL]
CREATE TABLE Teams (
  eid INTEGER,
  pname VARCHAR(100),
  hours INTEGER,
  PRIMARY KEY (ename, pname),
  FOREIGN KEY (eid) REFERENCES Employees (id) ON DELETE <action> ON UPDATE <action>,
  FOREIGN KEY (pname) REFERENCES Projects (name) ON DELETE NO ACTION ON UPDATE CASCADE 
  /* 'NO ACTION' is optional since it's default */
);
  \end{lstlisting}

  \subsection{Check Constraint}
  \begin{itemize}
    \item specify that column values must satisfy a boolean expression
    \item scope: one table, single row
    \item not a structural integrity constraint
    \item column constraint:
      \begin{lstlisting}[style=mySQL]
CREATE TABLE Teams (
  eid INTEGER,
  hours INTEGER check (hours > 0), /* unnamed */
  minutes INTEGER constraint positive_hours check (hours > 0) /* named */
);  
      \end{lstlisting}
    \item table constraint:
      \begin{lstlisting}[style=mySQL]
CREATE TABLE Teams (
  eid INTEGER,
  ...
  CHECK (hours <= end_year), /* unnamed table */
  CONSTRAINT valid_lifetime CHECK (start_year <= end_year) /* named table */
);  
      \end{lstlisting}
    \item \code{CHECK} constraints can be complex boolean expressions:
      \begin{lstlisting}[style=mySQL]
CREATE TABLE Teams (
  ...
  CHECK (
    (pname = 'Hello' AND hours >= 30)
    OR
    (panme <> 'Hello' AND hours > 0)
  )
);  
      \end{lstlisting}
  \end{itemize}

  \subsection{Deferrable Constraints}
  \begin{itemize}
    \item default behaviour for constraints: checked immediately at the end of SQL statement execution
      \begin{itemize}
        \item violation causes statement to be rolled back
      \end{itemize}
    \item \textbf{deferrable constraints}: relaxed constraint checks
      \begin{itemize}
        \item check will be deferred to the \textit{end} of the transaction
        \item available for: \code{UNIQUE}, \code{PRIMARY KEY}, \code{FOREIGN KEY}
      \end{itemize}
    \item advantages
      \begin{itemize}
        \item no need to care about order of SQL statements within a transaction
        \item allows for cyclic FK constraints
        \item performance boost (when constraint checks are bottleneck)
      \end{itemize}
    \item disadvantages
      \begin{itemize}
        \item harder to troubleshoot
        \item data definition is no longer unambiguous
        \item performance penalty when performing queries
      \end{itemize}
  \end{itemize}

  \section{04. ENTITY RELATIONSHIP MODEL}
  \begin{itemize}
    \item all data is described in terms of \textbf{entities} and their \textbf{relationships}
    \item \definition{entity} objects that are distinguishable from other objects
      \begin{itemize}
        \item \definition{entity set} collection of entities of the same type
      \end{itemize}
    \item \definition{attribute} specific information describing an entity
      \begin{itemize}
        \item \definition{key attribute} uniquely identiifes each entity (underline)
        \item \definition{composite attribute} composed of multiple other attributes (oval of ovals)
        \item \definition{multivalued attribute} may comprise more than one value for a given entity (double-lined oval)
        \item \definition{derived attribute} derived from other attributes dashed oval)
      \end{itemize}
    \item \definition{relationship} association among two or more entities
      \begin{itemize}
        \item \definition{relationship set} collection of relationships of the same type
          \begin{itemize}
            \item may have their own attributes that describe the relationship
          \end{itemize}
      \end{itemize}
  \end{itemize}
  \includegraphics[width=0.4\linewidth]{cs2102-entity-relationship-model.png} 
  \includegraphics[width=0.5\linewidth]{cs2102-attribute-subtypes.png} 

  \subsubsection{relationship sets}
  \begin{itemize}
    \item \definition{role} descriptor of an entity set's participation in a relationship
      \begin{itemize}
        \item explicit role labels
          \\* \includegraphics[width=0.55\linewidth]{cs2102-relationship-role-label.png} 
      \end{itemize}
    \item \definition{degree} number of entity roles participating in a relationship 
      \begin{itemize}
        \item an $n$-ary relationship set involves $n$ entity roles (where $n$ is the degree of the relationship set)
        \item binary/ternary relationship set
        \item general $n$-ary relation:
          \begin{itemize}
            \item $n$ participating entity sets $E_1, E_2, \dots, E_n$ 
            \item $k$ relationship attributes $A_1, A_2, \dots, A_k$
            \item $Key(E_i)$  $\rightarrow$ the attribtues of the selected key of entity set $E_i$
          \end{itemize}
      \end{itemize}
  \end{itemize}
  \includegraphics[width=0.4\linewidth]{cs2102-relationship-set.png} 


  \subsection{Cardinality Constraints}
  \begin{itemize}
    \item describes how often an entity can participate in a relationship \textbf{at most}
    \item 3 basic cardinality constraints:
      \begin{itemize}
        \item many-to-many
        \item many-to-one
        \item one-to-one
      \end{itemize}
  \end{itemize}

  \subsection{Participation Constraints}
  \begin{itemize}
    \item specifies if an entity has to participate in a relationship (lower bound)
    \item \definition{partial participation constraint} participation (of an entity in a relationship) is not mandatory (0 or more)
    \item \definition{total participation constraint} participation is mandatory (1 or more)
  \end{itemize}
  \begin{center}
    \begin{multicols}{2}
      \begin{tikzpicture}
        \node[rectangle, draw, minimum width = 0.6cm] (e) at (0,0) {E};
        \node[diamond, draw, aspect = 2] (r) at (2,0) {R};
        \draw[-latex] (e) -- (r);
      \end{tikzpicture}
      \\* each instance of E participates in 
      \\* \textbf{at most one} instance of R
      \\ \ 

      \begin{tikzpicture}
        \node[rectangle, draw, minimum width = 0.6cm] (e) at (0,0) {E};
        \node[diamond, draw, aspect = 2] (r) at (2,0) {R};
        \draw[-stealth, double, double distance = 1.2pt] (e) -- (r);
      \end{tikzpicture}
      \\* each instance of E participates in 
      \\* \textbf{exactly one} instance of R

      \begin{tikzpicture}
        \node[rectangle, draw, minimum width = 0.6cm] (e) at (0,0) {E};
        \node[diamond, draw, aspect = 2] (r) at (2,0) {R};
        \draw[double, double distance=1.2pt] (e) -- (r);
      \end{tikzpicture}
      \\* each instance of E participates in 
      \\* \textbf{at least one} instance of R
      \\ \ 

      \begin{tikzpicture}
        \node[rectangle, double, draw, minimum width = 0.6cm, double distance=1pt] (e) at (0,0) {E};
        \node[diamond, double, draw, aspect = 2, double distance=1pt] (r) at (1.5,0) {R};
        \node[rectangle, draw, minimum width = 0.6cm] (e2) at (3,0) {E'};
        \draw[-stealth, double, double distance=1.2pt] (e) -- (r);
        \draw[-] (r) -- (e2);
      \end{tikzpicture}
      \\* E is a \textbf{weak entity set} 
      with identifying owner E' 
      \& identifying relationship set R.
    \end{multicols}
  \end{center}

  \subsection{Dependency Constraints}
  \begin{itemize}
    \item \definition{weak entity sets} entity set that does not have its own key 
      \begin{itemize}
        \item can only be uniquely identified through the primary key of its \textbf{owner entity}
        \item existence depends on the existence of its owner entity
      \end{itemize}
  \end{itemize}

  \subsection{Alternative Representations}
  \begin{tightcenter}
    \includegraphics[width=0.9\linewidth]{cs2102-alternative-representation-cardinality-constraint.png} 
    \\ \textbf{Min/Max notation}
    \\* \includegraphics[width=0.4\linewidth]{cs2102-alternative-representation-minmax.png} 
  \end{tightcenter}

  \section{04-1. RELATIONAL MAPPING} 
  \begin{itemize}
    \item entity set $\rightarrow$ table
    \item handling composite/multivalued attributes
      \begin{enumerate}
        \item convert to a set of single-valued attributes (e.g. phone $\rightarrow$ phone1, phone2)
        \item additional table with FK constraint (e.g. PhoneNumbers with user\_id, phone)
        \item convert to one single-valued attribute (e.g. string containing everything)
      \end{enumerate}
  \end{itemize}

  \section{04-2. EXTENDED CONCEPTS}
  \subsection{ISA Hierarchy}
  \begin{itemize}
    \item "is a" relationship used to model generalisation/specialisation of entity sets
    \item every entity in a subclass is an entity in its superclass
      \begin{itemize}
        \item each subclass has specific attributes and/or relationships
      \end{itemize}
  \end{itemize}
  \subsubsection{constraints}
  \begin{itemize}
    \item \definition{overlap contraint} a superclass entity can belong to \textbf{multiple} subclasses
    \item \definition{covering constraint} a superclass entity \textbf{has to} belong to a subclass
  \end{itemize}
  \begin{tightcenter}
    \includegraphics[width=0.45\linewidth]{cs2102-isa-hierarchy-general.png} 
    \includegraphics[width=0.5\linewidth]{cs2102-isa-hierarchy-notations.png} 
  \end{tightcenter}

  \subsection{Aggregation}
  \begin{itemize}
    \item abstraction that treats relationships as higher-level entities
      \begin{itemize}
        \item e.g. treating 2 entities + 1 relationship as an entity set
      \end{itemize}
  \end{itemize}

  \section{05. SQL (QUERYING A DATABASE)}
  \begin{itemize}
    \item \definition{DQL} data query language
    \item duplicate tuples are allowed!
      \begin{itemize}
        \item use \code{DISTINCT} to eliminate duplicates
      \end{itemize}
  \end{itemize}
  \begin{minipage}[c]{0.3\linewidth}
    \includegraphics[width=0.9\linewidth]{cs2102-sql-execution-diagram.png} 
  \end{minipage}
  \begin{minipage}[c]{0.5\linewidth}
    \textbf{SELECT DISTINCT} $a_1, a_2, \dots, a_m$ \\* 
    \textbf{FROM} $r_1, r_2, \dots, r_n$ \\* 
    \textbf{WHERE} $c$

    \begin{tightcenter}
      $\Rightarrow$ corresponds to:
      \( {\displaystyle{\pi_{a_1, a_2, \dots, a_m} (\sigma_c(r_1 \times r_2 \times \dots \times r_n)) }} \) 
    \end{tightcenter}
  \end{minipage}

  \subsection{SELECT clause}
  \begin{itemize}
    \item wildcard \code{*} - include all attributes
    \item \code{expr \textbf{BETWEEN} <lower> \textbf{AND} <upper>} - basic value range conditions
      \begin{lstlisting}[style=mySQL]
SELECT * FROM countries 
WHERE (continent = 'Asia' OR continent = 'Europe')
  AND (population BETWEEN 500 AND 600);
      \end{lstlisting}
    \item \code{\textbf{||}} - concatenate strings
      \begin{lstlisting}[style=mySQL]
SELECT name, '$S' || ROUND((gdp/population) * 1.35) AS gdp_per_capita
FROM countries;
      \end{lstlisting}
    \item \code{\textbf{SELECT DISTINCT}} - remove duplicates
      \begin{itemize}
        \item tuples $(n_1, c_1)$ and $(n_2, c_2)$ are considered distinct 
          \\* $\iff$ \code{\textbf{$n_1$ IS DISTINCT FROM $n_2$}} $\lor$ \code{\textbf{$c_1$ IS DISTINCT FROM $c_2$}}
      \end{itemize}
  \end{itemize}

  \subsection{WHERE clause}
  \begin{itemize}
    \item \code{IS (NOT) NULL} 
      \begin{itemize}
        \item evaluates to true: \code{$null$ IS NULL}
        \item evaluates false: \code{$null$ = NULL} (unknown), \code{$null$ <> NULL}
      \end{itemize}
    \item \code{(NOT) LIKE} - pattern matching
      \begin{itemize}
        \item \code{\_} - match any single character
        \item \code{\%} - match any sequence of zero or more characters
      \end{itemize}
  \end{itemize}

  \subsection{SET Operations} 
  \begin{itemize}
    \item \code{UNION}, \code{INTERSECT}, \code{EXCEPT}
      \begin{itemize}
        \item will eliminate duplicate tuples from result
      \end{itemize}
    \item \code{UNION ALL}, \code{INTERSECT ALL}, \code{EXCEPT ALL}
      \begin{itemize}
        \item will NOT eliminate duplicate tuples from result
      \end{itemize}
    \item no ordering of tuples
  \end{itemize}

  \subsection{JOIN Queries}
  \begin{itemize}
    \item \code{JOIN} - interpreted as \code{INNER JOIN} by default
    \item \code{NATURAL JOIN} - identical attribute names can be reinforced with renaming
      \begin{itemize}
        \item joins based on attribute names
      \end{itemize}
    \item \code{LEFT OUTER JOIN} - same as \code{LEFT JOIN}
      \begin{itemize}
        \item keep only dangling tuples: \code{... WHERE c.country\_iso2 IS NULL;}
      \end{itemize}
    \item complex join queries
    \item equivalent queries:
      \begin{lstlisting}[style=mySQL]
SELECT c.name, n.name 
FROM cities AS c, countries AS n
WHERE c.country_iso2 = n.iso2;

SELECT c.name, n.name
FROM cities c INNER JOIN countries n
  ON c.country_iso2 = n.iso2;

SELECT c.name, n.name
FROM cities c JOIN countries n
  ON c.country_iso2 = n.iso2;
      \end{lstlisting}
  \end{itemize}

  \subsection{Subqueries}
  \begin{itemize}
    \item \definition{table alias} every subquery has to have a name to uniquely identify its attributes
      \begin{itemize}
        \item \textbf{column alias} is optional - \code{AS optional}
      \end{itemize}

    \item \code{\textbf{(NOT) IN}} - returns true if \textit{expr} matches \textbf{any} subquery row
      \begin{itemize}
        \item syntax: \code{expr \textbf{IN} (subquery)}, \code{expr \textbf{NOT IN} (subquery)}
        \item subquery must return \textit{exactly one} column
        \item \code{IN} can typically be replaced with (inner) joins
        \item \code{NOT IN} can typically be replaced with (outer) joins
          \begin{lstlisting}[style=mySQL]
SELECT name FROM COUNTRIES
WHERE name IN (SELECT name FROM cities)
   OR name IN ('Singapore', 'Hong Kong');
          \end{lstlisting}
      \end{itemize}

    \item \code{\textbf{ANY}} - returns true if comparison evaluates to true for \textit{at least one} subquery row
      \begin{itemize}
        \item syntax: \code{expr op \textbf{ANY} (subquery)}
        \item subquery must return \textit{exactly one} column
        \item expression is compared to each subquery row using \code{op} 
          \begin{lstlisting}[style=mySQL]
SELECT name, population FROM countries 
WHERE population < ANY (SELECT population FROM cities
                        WHERE country = 'GB');
          \end{lstlisting}
      \end{itemize}

    \item \code{\textbf{ALL}} - returns true if comparison evaluates to true for \textit{all} subquery rows
      \begin{itemize}
        \item syntax: \code{expr op \textbf{ALL} subquery}
          \begin{lstlisting}[style=mySQL]
SELECT name, continent, gdp FROM countries c1
WHERE gdp >= ALL(SELECT gdp FROM countries c2
                 WHERE c2.continent = c1.continent); 
                 -- c1 from outer query
          \end{lstlisting}
      \end{itemize}

    \item \code{\textbf{EXISTS}} - returns true if the subquery returns \textit{at least one} tuple
      \begin{itemize}
        \item syntax: \code{\textbf{EXISTS} (subquery)}, \code{\textbf{NOT EXISTS} (subquery)}
        \item \code{(NOT) EXISTS} subqueries are generally \textbf{correlated}
          \begin{itemize}
            \item uncorrelated $\Rightarrow$ will always give the same result $\Rightarrow$ redundant
          \end{itemize}
          \begin{lstlisting}[style=mySQL]
SELECT n.name FROM countries n
WHERE NOT EXISTS (SELECT * FROM cities c
                  where c.country_iso2 = n.iso2);
          \end{lstlisting}
      \end{itemize}



  \end{itemize}

  \subsubsection{correlated subquery}
  \begin{itemize}
    \item \definition{correlated subquery} relies on value(s) from outer query
    \item result of subquery depends on value of outer query
      \begin{itemize}
        \item potential performance issues
        \item potential naming ambiguity - use table aliases
      \end{itemize}
    \item \textbf{scoping rules}
      \begin{itemize}
        \item a table alias declared in subquery $Q$ can only be used in $Q$ or subqueries nested within $Q$
        \item if the same table alias is declared both in $Q$ and in an outer query (or undeclared), the declaration in Q is applied.
          \begin{itemize}
            \item aka when unsure, apply the smallest scope ("inner to outer")
          \end{itemize}
      \end{itemize}
  \end{itemize}

  \subsubsection{scalar subqueries}
  \begin{itemize}
    \item \definition{scalar subquery} returns a \textbf{single} value (1 row 1 column)
    \item can be used as an expression in queries
  \end{itemize}

  \subsubsection{row constructors}
  \begin{itemize}
    \item allow subqueries to return more than one attribute/column
    \item e.g. find all countries with higher population \textit{or} gdp than France \textit{or} Germany
  \end{itemize}
  \begin{lstlisting}[style=mySQL]
SELECT name, population AS pop, gdp FROM countries
WHERE ROW(pop, gdp) > ANY(SELECT population, gdp 
                          FROM countries
                          WHERE name IN ('Germany', 'France'));
  \end{lstlisting}

  \subsubsection{equivalent subqueries}
  \begin{itemize}
    \item \code{expr \textbf{IN} (subquery)} $\, \equiv \,$ \code{expr = \textbf{ANY} (subquery)}
    \item \code{expr1 op \textbf{ANY} (\textbf{SELECT} expr2 \textbf{FROM} ... \textbf{WHERE} ...)} 
      \\* $\, \equiv \,$ \code{\textbf{EXISTS} (\textbf{SELECT} * \textbf{FROM} ... \textbf{WHERE} ... \textbf{AND} expr1 op expr2)}
  \end{itemize}

  \subsection{Sorting}
  \begin{itemize}
    \item \code{ORDER BY} - sort by attribute(s), \code{ASC}/\code{DESC} 
    \item e.g. \code{ORDER BY n.name ASC, c.population DESC}
      \begin{itemize}
        \item second criteria only affects result if first criteria has ambiguity
      \end{itemize}
  \end{itemize}

  \subsection{Rank-based Selection}
  \begin{itemize}
    \item \code{LIMIT k} - return the first $k$ tuples of the result table
    \item \code{OFFSET i} - specify the position of the "first" tuple to be considered
      \begin{lstlisting}[style=mySQL]
-- e.g. find the "second" top 5 countries by GDP per capita
SELECT name, (gdp/population) AS gdp_per_capita FROM countries
ORDER BY gdp_per_capita DESC 
OFFSET 5 LIMIT 5;
      \end{lstlisting}
  \end{itemize}

  \section{06-1. SQL (AGGREGATION)}

  \begin{itemize}
    \item compute a single value from a set of tuples
    \item e.g. \code{MIN()}, \code{MAX()}, \code{AVG()}, \code{COUNT()}, \code{SUM()} 
      \begin{lstlisting}[style=mySQL]
SELECT MIN(population) as lowest,
       MAX(population) as highest,
       SUM(population) as world
FROM countries;
      \end{lstlisting}
  \end{itemize}

  \subsection{handling null values}
  \begin{tightcenter}
    \includegraphics[width=0.9\linewidth]{cs2102-aggregation-functions-summary.png} 
  \end{tightcenter}
  Let $R$ be an empty relation; let $S$ be a non-empty relation with $n$ tuples but ONLY null values for $A$.
  \begin{tightcenter}
    \includegraphics[width=0.9\linewidth]{cs2102-aggregation-function-null.png} 
  \end{tightcenter}

  \subsection{signatures}
  \begin{itemize}
    \item \code{\textbf{MIN}}, \code{\textbf{MAX}} : defined for all data types, returns same data type as input
    \item \code{\textbf{COUNT}} : defined for all \textbf{numeric} data types
      \begin{itemize}
        \item \code{\textbf{SUM}(INTEGER) -> BIGINT}, \code{\textbf{SUM}(REAL) -> REAL}
      \end{itemize}
    \item \code{\textbf{COUNT}} : defined for all datatypes; \code{\textbf{COUNT}(...) -> BIGINT}
  \end{itemize}

  \subsection{GROUP BY}
  \begin{itemize}
    \item given \code{GROUP BY $a_1, a_2, \dots, a_n$}, 2 tuples $t$ and $t'$ belong to the same group if 
      \\* $\forall k \in (1, n)$,  \code{(t.a$_k$ \textbf{IS NOT DISTINCT FROM} t'.a$_k$)} evaluates to \code{TRUE}.
    \item logical partition of relation into groups based on values for specified attributes
    \item one result tuple for each group
    \item if column $A_i$ or table $R$ appears in the SELECT clause, one of the following conditions must hold:
      \begin{enumerate}
        \item $A_i$ appears in the GROUP BY clause
        \item $A_i$ appears as input of an aggregation function in the SELECT clause
        \item the primary key of $R$ appears in the GROUP BY clause
      \end{enumerate}
  \end{itemize}
  \begin{lstlisting}[style=mySQL]
-- for each continent, find the lowest, highest and total country population and number of countries
SELECT continent,
  MIN(population) AS lowest,
  MAX(population) AS highest,
  SUM(population) AS overall,
  COUNT(*)        AS number_of_countries,
FROM countries
GROUP BY continent;
  \end{lstlisting}

  \subsubsection{HAVING}
  \begin{itemize}
    \item conditions check for each group defined by \code{GROUP BY} clause
      \begin{itemize}
        \item cannot be used without a \code{GROUP BY} clause
      \end{itemize}
    \item if column $A_i$ of table $R$ apears in hte \code{HAVING} clause, one of the following conditions must hold:
      \begin{enumerate}
        \item $A_i$ appears in the GROUP BY clause
        \item $A_i$ appears as input of an aggregation function in the HAVING clause
        \item the primary key of $R$ appears in the GROUP BY clause
      \end{enumerate}
      \begin{lstlisting}[style=mySQL]
-- find all routes served by >12 airlines
SELECT from_code, to_code, COUNT(*) AS num_airlines
FROM routes 
GROUP BY from_code, to_code
HAVING COUNT(*) > 12;
      \end{lstlisting}
  \end{itemize}

  \section{06-2. SQL (CONDITIONAL EXPRESSION)}
  \subsection{CASE}
  \begin{itemize}
    \item generic conditional expression, similar to if/else
    \item two basic ways of formulating CASE expressions:
  \end{itemize}
  \begin{multicols}{2}
    \begin{lstlisting}[style=mySQL]
CASE
  WHEN condition1 THEN result1
  WHEN condition2 THEN result2
  ...
  WHEN condition_n THEN result_n
  ELSE result0
END
    \end{lstlisting}
    \begin{lstlisting}[style=mySQL]
CASE expression
  WHEN value1 THEN result1
  WHEN value2 THEN result2
  ...
  WHEN condition_n THEN result_n
  ELSE result0
END
    \end{lstlisting}
  \end{multicols}

  \subsection{COALESCE}
  \begin{itemize}
    \item \code{COALESCE(val1, val2, ...)} returns the first NON-NULL value in the list of input arguments
    \item returns NULL if all values in the list of input arguments are NULL
    \item e.g. \code{SELECT COALESCE(null, null, 1, null, 2) -> 1}
  \end{itemize}

  \subsection{NULLIF}
  \begin{itemize}
    \item \code{NULLIF(val1, val2)} returns NULL if \code{val1 = val2}; otherwise return \code{val1}
  \end{itemize}

  \section{06-3. SQL (STRUCTURING QUERIES)}
  \subsection{Common Table Expressions (CTEs)}

  \begin{minipage}[c]{0.2\linewidth}
    general syntax:
    \\ \textbf{WITH}
    \\* $\quad$ C$_1$ \textbf{AS} (Q$_1$)
    \\* $\quad$ C$_2$ \textbf{AS} (Q$_2$)
    \\* $\quad \cdots,$ ...,
    \\* $\quad$ C$_n$ \textbf{AS} (Q$_n$)
  \end{minipage}
  \begin{minipage}[c]{0.75\linewidth}
    \begin{lstlisting}[style=mySQL]
WITH CTE_name AS 
  -- <CTE BODY>
  (SELECT n.name AS country, ...
   FROM ...
   WHERE ...)
  -- </CTE BODY>
SELECT i.country, ...
FROM CTE_name i   /* CTE usage */ 
  LEFT OUTER JOIN routes r N i.code = r.to_code
...
    \end{lstlisting}
  \end{minipage}

  \begin{itemize}
    \item general syntax
      \begin{itemize}
        \item each $C_i$ is the name of a temporary table defined by query $Q_i$ 
        \item each $C_i$ can reference any other $C_j$ that has been declared \textit{before} $C_i$ 
        \item SQL statement $S$ can reference any possible subset of all $C_i$
      \end{itemize}
  \end{itemize}

  \subsection{Views}
  \begin{itemize}
    \item \textit{permanently} named \textbf{query} (virtual relation)
      \begin{itemize}
        \item query is stored (not the query result) $\Rightarrow$ re-executed whenever it is used
      \end{itemize}
    \item can be used like normal tables
      \begin{itemize}
        \item no restriction when used in SELECT statements
        \item restrictions when using INSERT/UPDATE/DELETE
      \end{itemize}
  \end{itemize}
  \begin{lstlisting}[style=mySQL]
CREATE VIEW ViewName AS
  SELECT ...
  FROM ...
  WHERE ... ;
  \end{lstlisting}

  \subsection{RECURSIVE QUERIES}
  \begin{itemize}
    \item using CTEs and \code{RECURSIVE}
  \end{itemize}
  \begin{lstlisting}[style=mySQL]
WITH RECURSIVE CTE_name (col_a, col_b, col_c) AS (
  SELECT ... , 0 as counter
  FROM ...  WHERE ...
  UNION ALL
  SELECT ..., cte.counter + 1
  FROM CTE_name cte, ... WHERE ...
  AND cte.counter < 3  /* base case */
)
SELECT DISTINCT counter, ... 
FROM CTE_name
ORDER BY counter ASC;
  \end{lstlisting}

  \subsection{UNIVERSAL QUANTIFICATION}
  \begin{itemize}
    \item no direct support for universal quantification (e.g. find users who have visited \textit{all} countries)
    \item possible workarounds:
  \end{itemize}
  \begin{multicols}{2}
    \begin{lstlisting}[style=mySQL]
SELECT n.iso2
FROM countries n
WHERE NOT EXISTS (SELECT 1
 FROM visited v
 WHERE v.iso2 = n.iso2
AND v.user_id = x);
    \end{lstlisting}

    \begin{lstlisting}[style=mySQL]
  SELECT u.user_id, u.name
  FROM users u, visited v
  WHERE u.user_id = v.user_id
  GROUP BY u.user_id
  HAVING COUNT(*) = (SELECT COUNT(*) FROM countries);
    \end{lstlisting}
  \end{multicols}




\end{multicols}

\hrulefill \\
% \dotfill

\begin{multicols}{2}
  \section{SUMMARY: RELATIONAL MODEL}
  \begin{center}
    {\rowcolors{2}{gray!15}{gray!5}\begin{tabular}
        {ll}
        \rowcolor{cyan!10}
        \textbf{Term} & \textbf{Description} \\ \hline
        attribute & column of a table \\
        domain & set of possible values for an attribute \\
        attribute value & element of a domain \\ 
        relation schema & set of attributes (with their data types + relation name) \\
        relation & set of tuples \\
        tuple & roles of a table \\
        database schema & set of relation schemas \\
        database & set of relations / tables \\ 
        key & minimal set of attributes uniquely identifying a tuple in a relation \\
        primary key & selected key (in case of multiple candidate keys) \\
        foreign key & set of attributes that is a key in referenced relation \\
        prime attribute & attribute of a key \\
        \hline
      \end{tabular}
    }
  \end{center}

  \section{CONCEPTUAL EVALUATION OF QUERIES}
  \includegraphics[width=0.9\linewidth]{cs2102-conceptual-evaluation-of-queries.png} 
\end{multicols}

\end{document}
