\documentclass[10pt, landscape]{article}
\usepackage[scaled=0.92]{helvet}
\usepackage{calc}
\usepackage{multicol}
\usepackage[a4paper,margin=3mm,landscape]{geometry}
\usepackage{amsmath,amsthm,amsfonts,amssymb}
\usepackage{color,graphicx,overpic}
\usepackage{hyperref}
\usepackage{newtxtext} 
\usepackage{enumitem}
\usepackage[table]{xcolor}
\usepackage{mathtools}
\setlist{nosep}

% for including images
\graphicspath{ {./images/} }


\pdfinfo{
  /Title (CS2102.pdf)
  /Creator (TeX)
  /Producer (pdfTeX 1.40.0)
  /Author (Jovyn Tan)
  /Subject (CS2102)
/Keywords (CS2102, nus,cheatsheet,pdf)}

% Turn off header and footer
\pagestyle{empty}

% redefine section commands to use less space
\makeatletter
\renewcommand{\section}{\@startsection{section}{1}{0mm}%
  {-1ex plus -.5ex minus -.2ex}%
  {0.5ex plus .2ex}%x
{\normalfont\large\bfseries}}
\renewcommand{\subsection}{\@startsection{subsection}{2}{0mm}%
  {-1explus -.5ex minus -.2ex}%
  {0.5ex plus .2ex}%
{\normalfont\normalsize\bfseries}}
\renewcommand{\subsubsection}{\@startsection{subsubsection}{3}{0mm}%
  {-1ex plus -.5ex minus -.2ex}%
  {1ex plus .2ex}%
{\normalfont\small\bfseries}}%
\makeatother

\renewcommand{\familydefault}{\sfdefault}
\renewcommand\rmdefault{\sfdefault}
%  makes nested numbering (e.g. 1.1.1, 1.1.2, etc)
\renewcommand{\labelenumii}{\theenumii}
\renewcommand{\theenumii}{\theenumi.\arabic{enumii}.}
\renewcommand\labelitemii{•}
\renewcommand\labelitemiii{•}

\definecolor{mathblue}{cmyk}{1,.72,0,.38}
\everymath\expandafter{\the\everymath \color{mathblue}}

% Don't print section numbers
\setcounter{secnumdepth}{0}

\setlength{\parindent}{0pt}
\setlength{\parskip}{0pt plus 0.5ex}
%% this changes all items (enumerate and itemize)
\setlength{\leftmargini}{0.5cm}
\setlength{\leftmarginii}{0.5cm}
\setlist[itemize,1]{leftmargin=2mm,labelindent=1mm,labelsep=1mm}
\setlist[itemize,2]{leftmargin=4mm,labelindent=1mm,labelsep=1mm}

% adding my commands
\input{../commands/style-helpers.tex}
\input{../commands/code.tex}
\input{../commands/math.tex}
\input{../commands/joins.tex}
% -----------------------------------------------------------------------

\begin{document}
\raggedright
\footnotesize
\begin{multicols}{3}

  % multicol parameters
  % These lengths are set only within the two main columns
  \setlength{\columnseprule}{0.25pt}
  \setlength{\premulticols}{1pt}
  \setlength{\postmulticols}{1pt}
  \setlength{\multicolsep}{1pt}
  \setlength{\columnsep}{2pt}

  \begin{center}
    \fbox{%
      \parbox{0.8\linewidth}{\centering \textcolor{black}{
          {\Large\textbf{CS2102}}
        \\ \normalsize{AY21/22 SEM 1}}
        \\ {\footnotesize \textcolor{gray}{github/jovyntls}}
      }%
    }
  \end{center}

  \section{01. DBMS: DATABASE MANAGEMENT SYSTEMS}
  \begin{itemize}
    \item set of universal and powerful \textbf{functionalities}  for data management
    \item \textbf{database system}: DBMS (functionality) supporting several databases
      \begin{itemize}
        \item DBS = DMBS + n*DB
      \end{itemize}
    \item \textbf{data model}: framework to specify the structure of a DB
    \item \textbf{schema}: describes the DB structure using concepts provided by the data model
    \item \textbf{schema instance}: content of a DB at a particular time
  \end{itemize}

  \subsection{Transactions}
  \begin{itemize}
    \item \textbf{transaction}, \(T\): a finite sequence of database operations
      \begin{itemize}
        \item smallest logical unit of work from an application perspective
      \end{itemize}
    \item guarantees the \textbf{ACID} properties
  \end{itemize}
  \begin{tightcenter}
    \includegraphics[width=0.9\linewidth]{cs2102-transition-graph.png}
  \end{tightcenter}

  \subsubsection{ACID properties}
  \begin{enumerate}
    \item \textbf{Atomicity} \(\rightarrow\) either all effects of $ T $ are reflected in the database, or none
    \item \textbf{Consistency}  \(\rightarrow\) the execution of $ T $ guarantees to yield a \textit{correct state} of the DB
    \item \textbf{Isolation} \(\rightarrow\)  execution of T is \textit{isolated} from the effects of concurrent transactions
    \item \textbf{Durability} \(\rightarrow\) after the commit of $ T $, its effects are \textit{permanent}  in case of failures
  \end{enumerate}

  \subsection{Serial vs Concurrent Execution}
  \subsubsection{Serial Execution}
  \begin{itemize}
    \item $ \checkmark $ \textit{correct} final result
    \item $ \times $ less (unoptimised) resource utilisation; low throughput
  \end{itemize}

  \subsubsection{Serializability}
  \begin{itemize}
    \item Requirement for Concurrent Execution: \textbf{serializable transaction execution} 
      \begin{itemize}
        \item (concurrent execution of a set of transactions is) \textbf{serializable} \(\rightarrow\) execution is equivalent to some serial execution of the same set of transactions
        \item \textbf{equivalent} \(\rightarrow\) they have the same \textit{effect}  on the data
      \end{itemize}
  \end{itemize}

  \subsubsection{Core tasks of DBMS}
  \begin{itemize}
    \item Support \textit{concurrent executions} of transactions - to optimise performance
    \item enforce \textit{serializability} of concurrent executions - to ensure integrity of data
  \end{itemize}

  \section{01-1. RELATIONAL MODEL}
  \begin{itemize}
    \item \definition{relation schema} defines a relation
      \begin{itemize}
        \item specifies the \textbf{attributes} (columns) and data constraints
        \item \definition{data constraints} limits the kind of data you can put into the database
      \end{itemize}
    \item \definition{relational database schema} set of relation schemas + data constraints
      \begin{itemize}
        \item TableName(col\_1, col\_2, col\_3) with dom(col\_1) = \{x, y, z\}, ...
      \end{itemize}
    \item \definition{relational database} collection of tables
  \end{itemize}

  \begin{itemize}
    \item \definition{domain} a set of \textit{atomic} values
      \begin{itemize}
        \item domain of attribute $ A_i $, $ dom(A_i) =$ set of possible values for $ A_i $
        \item for each value $ v $ of attribute $ A_i $, $ v \in dom(A_i) $ or $ v = $ \code{null}
          \begin{itemize}
            \item \code{null}: special value indicating that $ v $ is not known or specified
          \end{itemize}
        \item e.g. dom(course) = \{cs2102, cs2030, cs2040\}
      \end{itemize}
    \item \definition{relation} a set of \textit{tuples} 
      \begin{itemize}
        \item $ R(A_1, A_2, \dots, A_n) $ : relation schema with name $ R $ and $ n $ attributes $ A_1, A_2, \dots, A_n $
        \item each instance of schema $ R $ is a relation which is a subset of $ \{(a_1, a_2, \dots, a_n) \mid a_i \in dom(A_i) \cup \{null\}\} $
      \end{itemize}
  \end{itemize}


  \section{01-2. ENSURING DATA INTEGRITY}
  \begin{itemize}
    \item \definition{integrity constraint} condition that restricts what constitutes valid data
      \begin{itemize}
        \item DBMS will check that tables only ever contain valid data
      \end{itemize}
    \item \definition{structural} (integrity) inherent to the data model 
    \item 3 main strucutral integrity constraints of the Relation Model
      \begin{enumerate}
        \item Domain constraints
        \item Key constraints
        \item Foreign key constraints
      \end{enumerate}
  \end{itemize}

  \subsection{Key Constraints}
  \begin{itemize}
    \item \definition{superkey} subset of attributes that \textit{uniquely} identifies a tuple in a relation
      \begin{itemize}
        \item e.g. \{id, title\}
      \end{itemize}
    \item \definition{key} superkey that is also \textbf{minimal} 
      \begin{itemize}
        \item no proper subset of the key is a superkey
        \item e.g. \{id\}
      \end{itemize}
    \item \definition{candidate keys} set of all keys for a relation
    \item \definition{primary key} selected candidate key for a relation
      \begin{itemize}
        \item \textit{cannot} be \code{null} $ \Rightarrow $  \textbf{entity integrity constraint} 
      \end{itemize}
  \end{itemize}

  \subsection{Foreign Key Constraints}
  \begin{itemize}
    \item \definition{foreign key} subset of attributes of relation $ A $ if it refers to the \textit{primary key}  in a relation $ B $.
    \item each foreign key in a relation must:
      \begin{enumerate}
        \item appear as a \textbf{primary key} in the referenced relation, OR:
        \item be a \code{null} value
      \end{enumerate}
  \end{itemize}

  \section{01-3. SUMMARY}
  \begin{tightcenter}
    \includegraphics[width=0.9\linewidth]{cs2102-relational-model-example.png}
  \end{tightcenter}

  \section{02. RELATIONAL ALGEBRA}
  \begin{itemize}
    \item \definition{algebra} mathematical system of operands and operators
      \begin{itemize}
        \item \textbf{operands}: variables or values from which new values can be constructed
        \item \textbf{operators}: symbols denoting procedures that construct new values from given values
      \end{itemize}
    \item \definition{relation algebra} procedural query language
      \begin{itemize}
        \item \textbf{operands}: relations or variables representing relations
        \item \textbf{operators}: transform one or more input relations into one output relation
      \end{itemize}
  \end{itemize}

  \subsection{Closure Property}
  \begin{itemize}
    \item \definition{closure} relations are \textit{closed}  under relational algebra
      \begin{itemize}
        \item all input operands and outputs of all operators are \textit{relations} 
        \item the output of one operator can serve as input for subsequent operators
      \end{itemize}
    \item allows for nesting of relational operators $\Rightarrow$ \textbf{relational algebra expressions} 
  \end{itemize}

  \section{02-1. BASIC OPERATORS}
  \subsection{UNARY OPERATORS}

  \subsubsection{Selection, $ \sigma_c $}
  \begin{itemize}
    \item \definition{$\sigma_c(R)$} selects all tuples from a relation  $ R $ (i.e. rows from a table) that satisfy condition $ c $.
      \begin{itemize}
        \item for each tuple $ t \in R, t \in \sigma_c(R) \iff c $ evaluates to true on $ t $ 
        \item input and output relation have the same schema
      \end{itemize}
    \item \definition{selection condition} 
      \begin{itemize}
        \item a \textit{boolean expression} of one of the following forms:
          \begin{itemize}
            \item constant selection - attribute \textbf{op} constant
            \item attribute selection - attribute$_1$ \textbf{op} attribute$_2$
            \item expr$_1 \land $ expr$ _2 ; \quad$ expr$_1 \lor $ expr$ _2 ; \quad$ item $ \lnot $ expr $ ; \quad $(expr)
          \end{itemize}
        \item with \textbf{op} $\in \{=, <>, <, \leq, \geq, >\}$
          \begin{itemize}
            \item \textbf{operator precedence}: (), \textbf{op}, $\lnot$, $\land$, $\lor$
          \end{itemize}
        \item handling \code{null} values
          \begin{itemize}
            \item comparison operation with \code{null} $\Rightarrow$ \textbf{unknown} 
            \item arithmetic operation with \code{null} $\Rightarrow$ \code{null} 
          \end{itemize}
      \end{itemize}
  \end{itemize}

  \subsubsection{Projection, $\pi_\ell$}
  \begin{itemize}
    \item \definition{$\pi_\ell(R)$} projects all attributes of a given \textbf{relation}  specified in list $\ell$
      \begin{itemize}
        \item \textit{relation} = set of tuples $\Rightarrow$ duplicates removed from output relation!
        \item \textbf{order} of attributes matters!
        \item i.e. projects all columns of a table specified in list $\ell$
      \end{itemize}
  \end{itemize}

  \subsubsection{Renaming, $\rho_\ell$}
  \begin{itemize}
    \item \definition{$\rho_\ell(R)$} renames the attributes of a relation  $R$ 
      \\* $R$ is a relation with schema $R(A_1, A_2, \dots, A_n)$
    \item 2 possible formats for $\ell$
      \begin{itemize}
        \item $\ell$ is the new \textit{schema} in terms of the new attribute names
          \begin{itemize}
            \item $\ell = (B_1, B_2, \dots, B_n)$; $B_i = A_i$ if attribute $A_i$ does not get renamed
          \end{itemize}
        \item $\ell$ is a list of attribute renamings of the form: $B_i \leftarrow A_i, \dots, B_k \leftarrow A_k$
          \begin{itemize}
            \item each renaming $B_j \leftarrow A_j$ renames attribute $A_j$ to attribute $B_j$
            \item order of renaming doesn't matter
          \end{itemize}
      \end{itemize}
  \end{itemize}

  \subsection{SET OPERATORS}
  \begin{itemize}
    \item \definition{union} $R \cup S$ returns a relation with all tuples that are in both $R$ \textbf{or}  $S$
    \item \definition{intersection} $R \cap S$ ... all tuples that are in both $R$ \textbf{and}  $S$ 
    \item \definition{set difference} $R - S$ ... all the tuples that are in  $R$ \textbf{but not in}  $S$
  \end{itemize}
  ! requirement for all set operators: $R$ and $S$ must be \textbf{union-compatible} 

  \subsubsection{Union Compatibility}
  \begin{itemize}
    \item two relations $R$ and $S$ are \definition{union-compatible} if
      \begin{itemize}
        \item $R$ and $S$ have the same number of attributes and
        \item the corresponding attributes have the \textit{same or compatible domains} 
        \item BUT $R$ and $S$ do not have to use the same attribute names
      \end{itemize}
  \end{itemize}

  \subsection{CROSS PRODUCT}
  \begin{itemize}
    \item \definition{cross product} combines two relations $R$ and $S$ by forming all pairs of tuples from the two relations
      \begin{itemize}
        \item given two relations $R(A, B, C)$ and $S(X, Y)$,  $R \times S$ returns a relation with schema $(A, B, C, X, Y)$ defined as 
          \\* $R \times S = \{(a, b, c, x, y) \mid (a, b, c) \in R, (x, y) \in S\}$
      \end{itemize}
    \item \textbf{size} of cross product $= \abs{R}*\abs{S}$
  \end{itemize}

  \section{02-2. JOIN OPERATORS}

  \subsection{Inner Joins $\theta$-join}
  \begin{itemize}
    \item eliminate all tuples that do not satisfy a matching criteria (i.e. \textbf{attribute selection} )
  \end{itemize}
  $\theta$-join
  \begin{itemize}
    \item the $\theta$-join $R\bowtie_\theta S$ of two relations $R$ and $S$ is defined as
      \begin{tightcenter}
        \( {\displaystyle{R \bowtie_\theta S = \sigma_\theta(R \times S)}} \) 
      \end{tightcenter}
  \end{itemize}

  Equi Join  $\Join$
  \begin{itemize}
    \item special case of $\theta$-join defined over the  \textbf{equality} operator ($=$) only
  \end{itemize}

  Natural Join $\Join$ 
  \begin{itemize}
    \item the \definition{natural join} (of two relations $R$ and $S$) is defined as 
      \\* $R \Join S = \pi_\ell(R\Join_c \rho_{b_i \leftarrow a_i, \dots, b_k \leftarrow a_k}(S))$
      \begin{itemize}
        \item $A=\{a_i, \dots, a_k\}$ is the set of attributes that $R$ and $S$ have in common
        \item $c = ((a_i = b_i) \land \dots \land (a_k = b_k))$
        \item $\ell =$ list of all attributes of $R$ + list of all attributes in $S$ that are \textbf{not in}  $A$
      \end{itemize}
    \item performed over all attributes that $R$ and $S$ have in common
      \begin{itemize}
        \item no explicit matching criteria has to be specified
      \end{itemize}
    \item output relation contains the common attributes of $R$ and $S$ only \textit{once} 
  \end{itemize}

  \subsection{Outer Joins}
  \begin{itemize}
    \item \definition{dangling tuples} tuples in $R$ or $S$ that do not match with tuples in the other relation
      \begin{itemize}
        \item \definition{$\textit{dangle}(R \Join_\theta S)$} set of dangling tuples in  $R$ wrt to $R \Join_\theta S$
          \begin{itemize}
            \item $\textit{dangle}(R \Join_\theta S) \subseteq R$
          \end{itemize}
        \item always removed by inner joins, kept by outer joins
        \item missing attribute values are padded with \code{null} 
      \end{itemize}
    \item \definition{$null(R)$} $n$-component \textbf{tuple}  of \code{null} values where $n$ is the number of attributes of $R$
  \end{itemize}

  \subsubsection{Definitions}
  \begin{itemize}
    \item \definition{left outer join}$R \lojoin_\theta S = R \Join_\theta S \cup (\textit{dangle}(R \Join_\theta S) \times \{\textit{null}(S)\}) $
    \item \definition{right outer join}$R \rojoin_\theta S = R \Join_\theta S \cup (\{\textit{null}(R)\} \times \textit{dangle}(S \Join_\theta R))$
    \item \definition{full outer join}$R \lojoin_\theta S$
      \\* $= R \Join_\theta S \cup (\textit{dangle}(R \Join_\theta S) \times \{\textit{null}(S)\}) \cup (\{\textit{null}(R)\} \times \textit{dangle}(S \Join_\theta R))$
  \end{itemize}

  \subsubsection{Natural Outer Joins}
  \begin{itemize}
    \item only equality operator is used for the join condition
    \item join is performed over all attributes that R and S have in common
    \item  output relation contains the common attributes of R and S only once
  \end{itemize}

  \section{03. SQL}
  \subsection{Overview}
  \begin{itemize}
    \item \textbf{domain-specific language} - used for relational databases
    \item \textbf{declarative language} - focuses on \textit{what} to compute, not \textit{how} to compute
  \end{itemize}

  \subsection{Data Types (psql)}
  \begin{itemize}
    \item user-defined types
    \item basic data types
      \begin{tightcenter}
        {\rowcolors{2}{gray!15}{gray!5}\begin{tabular}
            {ccc}
            \rowcolor{cyan!10} 
            \textbf{type} & \textbf{description} \\ \hline 
            boolean & logical Boolean \\ 
            integer & signed 4-byte integer \\
            float8 & double precision floating point number (8 bytes) \\
            numeric[(p, s)] & exact numeric of selectable preciison \\
            char(n) & fixed-length character string \\
            varchar(n) & variable-length character string \\
            text & variable-length character string \\
            date & calendar date (year month day) \\
            timestamp & date and time \\
            \hline
          \end{tabular}
        }
      \end{tightcenter}
    \item char, varchar, text: different sizes to optimise storage
      \begin{itemize}
        \item \code{varchar(n)} - $n$ is the maximum length 
        \item \code{char(n)} - storage size = maximum size = n (will be padded up to $n$ bytes)
        \item \code{text} - usually for very long strings
      \end{itemize}
  \end{itemize}

  \subsection{Types of Commands/Statements}
  \begin{tightcenter}
    \includegraphics[width=0.9\linewidth]{cs2102-sql-query-types.png}
  \end{tightcenter}

  \subsection{DDL (Data Definition)}

  \subsubsection{Create Tables}
  \begin{lstlisting}[style=mySQL]
CREATE TABLE Employees (
id     INTEGER,
name   VARCHAR(50),
age    INTEGER,
role   VARCHAR(50)
);
  \end{lstlisting}

  \subsubsection{Insert Data}
  \begin{lstlisting}[style=mySQL]
-- specifying all attribute values
INSERT INTO Employees VALUES (101, 'John', 25, 'developer');
-- specifying selected attribute values
INSERT INTO Employees (id, name) VALUES (102, 'Smith');
  \end{lstlisting}

  \subsubsection{Modify Schema}
  \begin{lstlisting}[style=mySQL]
-- change data type 
ALTER TABLE Projects ALTER COLUMN name TYPE VARCHAR(200); 
-- set default value 
ALTER TABLE Projects ALTER COLUMN start_year SET DEFAULT 2021; 
-- drop default value
ALTER TABLE Projects ALTER COLUMN start_year DROP DEFAULT; 
-- add new column with a default value
ALTER TABLE Projects ADD COLUMN budget NUMERIC DEFAULT 0.0; 
-- drop column from table
ALTER TABLE Projects DROP COLUMN budget; 
-- add constraint
ALTER TABLE Teams ADD CONSTRAINT eid_fkey FOREIGN KEY (eid) REFERENCES Employees (id);
-- drop constraint
ALTER TABLE Teams DROP CONSTRAINT eid_fkey; /* eid_fkey = name of constraint */
  \end{lstlisting}

  \subsubsection{Drop Tables}
  \begin{lstlisting}[style=mySQL]
DROP TABLE Projects;
-- check first if table exists; avoids throwing an error
DROP TABLE IF EXISTS Projects; 
-- will also delete FK constraint (but not referencing tables)
DROP TABLE Projects CASCADE; 
  \end{lstlisting}

  \subsection{DML (Data Manipulation)}

  \subsubsection{Delete Data}
  \begin{lstlisting}[style=mySQL]
-- deletes all tuples 
DELETE FROM Employees; 
-- deletes selected tuples
DELETE FROM Employees WHERE role='developer';
  \end{lstlisting}

  \subsubsection{Update Data}
  \begin{lstlisting}[style=mySQL]
UPDATE Employees 
SET age = age + 1
WHERE name = 'John';

UPDATE Employees
SET name=UPPER(name), 
    job=UPPER(job);

-- updates all values 
UPDATE Employees 
SET age = 0; 
  \end{lstlisting}

  \subsection{Handling NULLs}
  \begin{itemize}
    \item prerequisite for integrity constraints
    \item \textbf{comparison} operation with \code{null} $\Rightarrow$ \textit{unknown}
    \item \textbf{arithmetic} operation with \code{null} $\Rightarrow$ \code{null}
  \end{itemize}

  \subsubsection{IS (NOT) NULL comparison predicate}
  \begin{itemize}
    \item checks if values are equal to \code{null} 
      \begin{itemize}
        \item evaluates to true \textbf{iff} x is \code{null}
      \end{itemize}
    \item \code{x IS NOT NULL} $\equiv$ \code{NOT (x IS NULL)}
  \end{itemize}

  \subsubsection{IS (NOT) NOT DISTINCT comparison predicate}
  \begin{itemize}
    \item equivalent to $x <> y$ if $x$ and $ y$ are non-\code{null} values
      \begin{itemize}
        \item $x$ and $y$ both \code{null} $\Rightarrow$ \textit{false}
        \item only one value is \code{null} $\Rightarrow$ \textit{true}
      \end{itemize}
    \item \code{x IS NOT DISTINCT FROM y} $\equiv$ \code{NOT (x IS DISTINCT FROM y)}
  \end{itemize}
  \begin{tightcenter}
    {\rowcolors{2}{gray!15}{gray!5}\begin{tabular}
        {cccc}
        \rowcolor{cyan!10} 
        \textbf{x} & \textbf{y} & xy & \texttt{x IS DISTINCT FROM y} \\ \hline 
        1 & 1 & FALSE & FALSE \\ 
        1 & 2 & TRUE & TRUE \\
        \textit{null} & 1 & \textit{null} & TRUE \\
        \textit{null} & \textit{null} & \textit{null} & FALSE \\
        \hline
      \end{tabular}
    }
  \end{tightcenter}

  \section{03-1. CONSTRAINTS}
  \begin{itemize}
    \item \textbf{named}: name assigned by DBMS
    \item \textbf{unnamed}: name is specified - easier bookkeeping
    \item all column constraints can be specified as table constraints, except \code{NOT NULL}
      \begin{itemize}
        \item table constraints referring to a single column can be writen as column constraints
        \item column and table constraints can be combined
          \begin{lstlisting}[style=mySQL]
            ... id INTEGER NOT NULL,
            ...
            UNIQUE(id)
          \end{lstlisting}
      \end{itemize}
  \end{itemize}
  \subsection{Not-Null Constraints}
  \begin{lstlisting}[style=mySQL]
CREATE TABLE Employees (
  id   INTEGER NOT NULL, /* unnamed */
  name VARCHAR(50) CONSTRAINT nn_name NOT NULL, /* named */
  age  INTEGER,
  job  VARCHAR(50),
);
  \end{lstlisting}

  \subsection{Unique Constraints}
  \begin{itemize}
    \item \textbf{violation} (of a unique constraint defined on attributes $A$ and $B$):
      \begin{itemize}
        \item For any two tuples $t_i, t_k \in$ R, \\*
          $(t_i\cdot A <> t_k\cdot A)$ or  $(t_i\cdot B <> t_k \cdot B)$ evaluates to  \textbf{false}
        \item  !!! \code{null} rows will NOT violate unique key constraints
      \end{itemize}
    \item (un)named column constraint \\*
      \begin{lstlisting}[style=mySQL]
CREATE TABLE Employees (
  id   INTEGER UNIQUE, /* unnamed */
  pid  INTEGER CONSTRAINT u_id UNIQUE, /* named */
  name VARCHAR(50), age INTEGER,
  role VARCHAR(50)
);
      \end{lstlisting}
    \item (un)named table constraint
      \begin{lstlisting}[style=mySQL]
CREATE TABLE Employees (
  id   INTEGER,
  name VARCHAR(50), 
  UNIQUE(id),  /* unnamed */,
  CONTRAINT u_name UNIQUE (name) /* named */
);
      \end{lstlisting}
    \item unique constraints for multiple attributes: can only be specified using \textbf{table} constraints
      \begin{lstlisting}[style=mySQL]
CREATE TABLE Employees (
  id     INTEGER,
  name   VARCHAR(50),
  UNIQUE (id, name), /* unnamed */
  CONSTRAINT u_allocation (id, name)  /* named */
)
      \end{lstlisting}
  \end{itemize}

  \subsection{Primary Key Constraints}
  \begin{itemize}
    \item \definition{prime attributes} attributes of the primary key 
      \begin{itemize}
        \item cannot be null
      \end{itemize}
    \item primary key vs \code{UNIQUE NOT NULL}
      \begin{itemize}
        \item \code{UNIQUE NOT NULL} is a candidate key
        \item max 1 primary key, but any number of \code{UNIQUE NOT NULL} constraints
        \item FK constraints are only applicable to PKs in referenced table
      \end{itemize}
    \item PK contraint for one attribute:
      \begin{lstlisting}[style=mySQL]
CREATE TABLE Teams (
  eid INTEGER PRIMARY KEY, 
  ... 
);
      \end{lstlisting}
    \item PK constraint for multiple attributes:
      \begin{lstlisting}[style=mySQL]
CREATE TABLE Teams (
  eid INTEGER,
  pname VARCHAR(100),
  PRIMARY KEY (ename, pname), /* unnamed */
  CONSTRAINT pk_alloc PRIMARY KEY (eid, pname) /* named */
);
      \end{lstlisting}
  \end{itemize}

  \subsection{Foreign Key Constraints}
  \begin{itemize}
    \item each FK in the referencing relation \textbf{must}:
      \begin{itemize}
        \item appear as a PK in the referenced relation, OR
        \item be a \code{null} value
      \end{itemize}
  \end{itemize}
  \begin{lstlisting}[style=mySQL]
CREATE TABLE Teams (
  eid INTEGER,
  pname VARCHAR(100),
  hours INTEGER,
  PRIMARY KEY (ename, pname),
  /* Teams.eid -> Employees.id */
  FOREIGN KEY (eid) REFERENCES Employees (id), 
  /* Teams.pname -> Projects.name */
  FOREIGN KEY (pname) REFERENCES Projects (name)
);
  \end{lstlisting}

  \subsubsection{specifications for table changes}
  \begin{itemize}
    \item \code{ON DELETE/UPDATE}: Specify action in case of the violation of a foreign key constraint
      \begin{itemize}
        \item attempting to delete primary key will throw error if ON DELETE not specified
        \item specify behavior when data in referenced table changes
      \end{itemize}
    \item possible actions:
      \begin{itemize}
        \item \code{NO ACTION}: (\textbf{default value}) - rejects the delete/update if it violates constraint
        \item \code{RESTRICT}: similar to \code{NO ACTION}; checks that constraint cannot be deferred
        \item \code{CASCADE}: propagates delete/update to referencing tuples
        \item \code{SET DEFAULT}: updates FKs of referencing tuples to a specified default value
          \begin{itemize}
            \item !! default value must be a PK in the referenced table !!
          \end{itemize}
        \item \code{SET NULL}: update FKs of referencing tuples to \code{null}
          \begin{itemize}
            \item be careful for primary attributes
            \item corresponding column must be allowed to contain \code{null} values!
          \end{itemize}
      \end{itemize}
  \end{itemize}
  \begin{lstlisting}[style=mySQL]
CREATE TABLE Teams (
  eid INTEGER,
  pname VARCHAR(100),
  hours INTEGER,
  PRIMARY KEY (ename, pname),
  FOREIGN KEY (eid) REFERENCES Employees (id) ON DELETE <action> ON UPDATE <action>,
  FOREIGN KEY (pname) REFERENCES Projects (name) ON DELETE NO ACTION ON UPDATE CASCADE 
  /* 'NO ACTION' is optional since it's default */
);
  \end{lstlisting}

  \subsection{Check Constraint}
  \begin{itemize}
    \item specify that column values must satisfy a boolean expression
    \item scope: one table, single row
    \item not a structural integrity constraint
    \item column constraint:
      \begin{lstlisting}[style=mySQL]
CREATE TABLE Teams (
  eid INTEGER,
  hours INTEGER check (hours > 0), /* unnamed */
  minutes INTEGER constraint positive_hours check (hours > 0) /* named */
);  
      \end{lstlisting}
    \item table constraint:
      \begin{lstlisting}[style=mySQL]
CREATE TABLE Teams (
  eid INTEGER,
  ...
  CHECK (hours <= end_year), /* unnamed table */
  CONSTRAINT valid_lifetime CHECK (start_year <= end_year) /* named table */
);  
      \end{lstlisting}
    \item \code{CHECK} constraints can be complex boolean expressions:
      \begin{lstlisting}[style=mySQL]
CREATE TABLE Teams (
  ...
  CHECK (
    (pname = 'Hello' AND hours >= 30)
    OR
    (panme <> 'Hello' AND hours > 0)
  )
);  
      \end{lstlisting}
  \end{itemize}

  \subsection{Deferrable Constraints}
  \begin{itemize}
    \item default behaviour for constraints: checked immediately at the end of SQL statement execution
      \begin{itemize}
        \item violation causes statement to be rolled back
      \end{itemize}
    \item \textbf{deferrable constraints}: relaxed constraint checks
      \begin{itemize}
        \item check will be deferred to the \textit{end} of the transaction
        \item available for: \code{UNIQUE}, \code{PRIMARY KEY}, \code{FOREIGN KEY}
      \end{itemize}
    \item advantages
      \begin{itemize}
        \item no need to care about order of SQL statements within a transaction
        \item allows for cyclic FK constraints
        \item performance boost (when constraint checks are bottleneck)
      \end{itemize}
    \item disadvantages
      \begin{itemize}
        \item harder to troubleshoot
        \item data definition is no longer unambiguous
        \item performance penalty when performing queries
      \end{itemize}
  \end{itemize}



\end{multicols}

\hrulefill \\
% \dotfill

\begin{multicols}{2}
  \section{SUMMARY: RELATIONAL MODEL}
  \begin{center}
    {\rowcolors{2}{gray!15}{gray!5}\begin{tabular}
        {ll}
        \rowcolor{cyan!10}
        \textbf{Term} & \textbf{Description} \\ \hline
        attribute & column of a table \\
        domain & set of possible values for an attribute \\
        attribute value & element of a domain \\ 
        relation schema & set of attributes (with their data types + relation name) \\
        relation & set of tuples \\
        tuple & roles of a table \\
        database schema & set of relation schemas \\
        database & set of relations / tables \\ 
        key & minimal set of attributes uniquely identifying a tuple in a relation \\
        primary key & selected key (in case of multiple candidate keys) \\
        foreign key & set of attributes that is a key in referenced relation \\
        prime attribute & attribute of a key \\
        \hline
      \end{tabular}
    }
  \end{center}
\end{multicols}

\end{document}
